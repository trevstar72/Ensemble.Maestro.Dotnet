using Microsoft.Extensions.Logging;
using Ensemble.Maestro.Dotnet.Core.Agents;
using System.Collections.Concurrent;
using System.Text.Json;

namespace Ensemble.Maestro.Dotnet.Core.Services;

/// <summary>
/// Service for storing and managing individual code documents generated by MethodAgents
/// Provides collection and retrieval capabilities for BuilderAgent consumption
/// </summary>
public class CodeDocumentStorageService : ICodeDocumentStorageService
{
    private readonly ILogger<CodeDocumentStorageService> _logger;
    private readonly ConcurrentDictionary<string, List<CodeDocument>> _documentsByProject = new();
    private readonly ConcurrentDictionary<string, List<CodeDocument>> _documentsByCodeUnit = new();
    private readonly object _lockObject = new();

    public CodeDocumentStorageService(ILogger<CodeDocumentStorageService> logger)
    {
        _logger = logger;
    }

    public async Task<string> StoreCodeDocumentAsync(string projectId, string codeUnitName, string functionName, 
        AgentExecutionResult result, CancellationToken cancellationToken = default)
    {
        var document = new CodeDocument
        {
            Id = Guid.NewGuid().ToString("N"),
            ProjectId = projectId,
            CodeUnitName = codeUnitName,
            FunctionName = functionName,
            Content = result.OutputResponse ?? "",
            Language = ExtractLanguageFromContent(result.OutputResponse ?? ""),
            GeneratedAt = DateTime.UtcNow,
            GeneratedBy = "MethodAgent",
            QualityScore = result.QualityScore,
            ConfidenceScore = result.ConfidenceScore,
            TokensUsed = result.InputTokens + result.OutputTokens,
            GenerationCost = result.ExecutionCost,
            Status = "Generated"
        };

        lock (_lockObject)
        {
            // Store by project
            var projectKey = $"project:{projectId}";
            if (!_documentsByProject.ContainsKey(projectKey))
                _documentsByProject[projectKey] = new List<CodeDocument>();
            _documentsByProject[projectKey].Add(document);

            // Store by code unit
            var codeUnitKey = $"codeunit:{projectId}:{codeUnitName}";
            if (!_documentsByCodeUnit.ContainsKey(codeUnitKey))
                _documentsByCodeUnit[codeUnitKey] = new List<CodeDocument>();
            _documentsByCodeUnit[codeUnitKey].Add(document);
        }

        _logger.LogInformation("üìÑ Stored code document {DocumentId} for {CodeUnitName}.{FunctionName} ({Size} chars)",
            document.Id, codeUnitName, functionName, document.Content.Length);

        return document.Id;
    }

    public async Task<List<CodeDocument>> GetCodeDocumentsByProjectAsync(string projectId, 
        CancellationToken cancellationToken = default)
    {
        var projectKey = $"project:{projectId}";
        
        lock (_lockObject)
        {
            if (_documentsByProject.TryGetValue(projectKey, out var documents))
            {
                return documents.ToList(); // Return copy to avoid concurrent modification
            }
        }

        return new List<CodeDocument>();
    }

    public async Task<List<CodeDocument>> GetCodeDocumentsByCodeUnitAsync(string projectId, string codeUnitName, 
        CancellationToken cancellationToken = default)
    {
        var codeUnitKey = $"codeunit:{projectId}:{codeUnitName}";
        
        lock (_lockObject)
        {
            if (_documentsByCodeUnit.TryGetValue(codeUnitKey, out var documents))
            {
                return documents.ToList(); // Return copy to avoid concurrent modification
            }
        }

        return new List<CodeDocument>();
    }

    public async Task<CodeDocument?> GetCodeDocumentAsync(string documentId, 
        CancellationToken cancellationToken = default)
    {
        lock (_lockObject)
        {
            foreach (var projectDocs in _documentsByProject.Values)
            {
                var document = projectDocs.FirstOrDefault(d => d.Id == documentId);
                if (document != null)
                    return document;
            }
        }

        return null;
    }

    public async Task<BuildAggregationResult> AggregateDocumentsForBuildAsync(string projectId, 
        CancellationToken cancellationToken = default)
    {
        var documents = await GetCodeDocumentsByProjectAsync(projectId, cancellationToken);
        
        if (!documents.Any())
        {
            return new BuildAggregationResult
            {
                Success = false,
                Message = "No code documents found for project",
                ProjectId = projectId
            };
        }

        // Group documents by code unit and language
        var codeUnitGroups = documents.GroupBy(d => d.CodeUnitName).ToList();
        var languageGroups = documents.GroupBy(d => d.Language).ToList();

        var aggregatedFiles = new List<AggregatedCodeFile>();

        foreach (var unitGroup in codeUnitGroups)
        {
            var unitDocs = unitGroup.ToList();
            var primaryLanguage = unitDocs.GroupBy(d => d.Language)
                .OrderByDescending(g => g.Count())
                .First().Key;

            // Combine all functions for this code unit
            var combinedContent = GenerateCombinedCodeUnit(unitGroup.Key, unitDocs, primaryLanguage);
            
            aggregatedFiles.Add(new AggregatedCodeFile
            {
                FileName = GenerateFileName(unitGroup.Key, primaryLanguage),
                Content = combinedContent,
                Language = primaryLanguage,
                CodeUnitName = unitGroup.Key,
                FunctionCount = unitDocs.Count,
                TotalSize = combinedContent.Length
            });
        }

        _logger.LogInformation("üîß Aggregated {DocumentCount} code documents into {FileCount} buildable files for project {ProjectId}",
            documents.Count, aggregatedFiles.Count, projectId);

        return new BuildAggregationResult
        {
            Success = true,
            ProjectId = projectId,
            AggregatedFiles = aggregatedFiles,
            TotalDocuments = documents.Count,
            TotalCodeUnits = codeUnitGroups.Count,
            Languages = languageGroups.Select(g => g.Key).ToList(),
            Message = $"Successfully aggregated {documents.Count} documents into {aggregatedFiles.Count} buildable files"
        };
    }

    public async Task UpdateDocumentStatusAsync(string documentId, string status, string? errorMessage = null, 
        CancellationToken cancellationToken = default)
    {
        lock (_lockObject)
        {
            foreach (var projectDocs in _documentsByProject.Values)
            {
                var document = projectDocs.FirstOrDefault(d => d.Id == documentId);
                if (document != null)
                {
                    document.Status = status;
                    if (!string.IsNullOrEmpty(errorMessage))
                        document.ErrorMessage = errorMessage;
                    document.UpdatedAt = DateTime.UtcNow;
                    
                    _logger.LogInformation("üìù Updated document {DocumentId} status to {Status}", documentId, status);
                    return;
                }
            }
        }
    }

    private string ExtractLanguageFromContent(string content)
    {
        // Simple language detection based on content patterns
        if (content.Contains("public class") || content.Contains("namespace "))
            return "CSharp";
        if (content.Contains("interface ") && content.Contains("{"))
            return "TypeScript";
        if (content.Contains("def ") && content.Contains("class "))
            return "Python";
        if (content.Contains("public class") && content.Contains("package "))
            return "Java";
        
        return "Unknown";
    }

    private string GenerateCombinedCodeUnit(string codeUnitName, List<CodeDocument> documents, string language)
    {
        var functions = documents.Select(d => d.Content).ToList();
        
        return language switch
        {
            "CSharp" => GenerateCSharpCodeUnit(codeUnitName, functions),
            "TypeScript" => GenerateTypeScriptCodeUnit(codeUnitName, functions),
            "Python" => GeneratePythonCodeUnit(codeUnitName, functions),
            "Java" => GenerateJavaCodeUnit(codeUnitName, functions),
            _ => string.Join("\n\n", functions)
        };
    }

    private string GenerateCSharpCodeUnit(string codeUnitName, List<string> functions)
    {
        return $@"using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Ensemble.Maestro.Generated
{{
    /// <summary>
    /// Generated code unit: {codeUnitName}
    /// Contains {functions.Count} function(s) generated by MethodAgents
    /// </summary>
    public class {codeUnitName}
    {{
{string.Join("\n\n        ", functions.Select(f => IndentCode(f, 2)))}
    }}
}}";
    }

    private string GenerateTypeScriptCodeUnit(string codeUnitName, List<string> functions)
    {
        return $@"/**
 * Generated code unit: {codeUnitName}
 * Contains {functions.Count} function(s) generated by MethodAgents
 */
export class {codeUnitName} {{
{string.Join("\n\n", functions.Select(f => IndentCode(f, 1)))}
}}";
    }

    private string GeneratePythonCodeUnit(string codeUnitName, List<string> functions)
    {
        var docString = $@"# Generated code unit: {codeUnitName}
# Contains {functions.Count} function(s) generated by MethodAgents";
        
        var functionCode = string.Join("\n\n", functions.Select(f => IndentCode(f, 1)));
        
        return $@"{docString}

class {codeUnitName}:
{functionCode}";
    }

    private string GenerateJavaCodeUnit(string codeUnitName, List<string> functions)
    {
        return $@"package com.ensemble.maestro.generated;

/**
 * Generated code unit: {codeUnitName}
 * Contains {functions.Count} function(s) generated by MethodAgents
 */
public class {codeUnitName} {{
{string.Join("\n\n", functions.Select(f => IndentCode(f, 1)))}
}}";
    }

    private string IndentCode(string code, int indentLevel)
    {
        var indent = new string(' ', indentLevel * 4);
        return string.Join("\n", code.Split('\n').Select(line => indent + line));
    }

    private string GenerateFileName(string codeUnitName, string language)
    {
        return language switch
        {
            "CSharp" => $"{codeUnitName}.cs",
            "TypeScript" => $"{codeUnitName}.ts",
            "Python" => $"{codeUnitName}.py",
            "Java" => $"{codeUnitName}.java",
            _ => $"{codeUnitName}.txt"
        };
    }
}

/// <summary>
/// Represents an individual code document generated by a MethodAgent
/// </summary>
public class CodeDocument
{
    public string Id { get; set; } = string.Empty;
    public string ProjectId { get; set; } = string.Empty;
    public string CodeUnitName { get; set; } = string.Empty;
    public string FunctionName { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string Language { get; set; } = string.Empty;
    public DateTime GeneratedAt { get; set; } = DateTime.UtcNow;
    public DateTime? UpdatedAt { get; set; }
    public string GeneratedBy { get; set; } = string.Empty;
    public int QualityScore { get; set; }
    public int ConfidenceScore { get; set; }
    public int TokensUsed { get; set; }
    public decimal GenerationCost { get; set; }
    public string Status { get; set; } = "Generated"; // Generated, Building, Built, Error
    public string? ErrorMessage { get; set; }
}

/// <summary>
/// Result of aggregating individual code documents into buildable files
/// </summary>
public class BuildAggregationResult
{
    public bool Success { get; set; }
    public string ProjectId { get; set; } = string.Empty;
    public string Message { get; set; } = string.Empty;
    public List<AggregatedCodeFile> AggregatedFiles { get; set; } = new();
    public int TotalDocuments { get; set; }
    public int TotalCodeUnits { get; set; }
    public List<string> Languages { get; set; } = new();
    public DateTime AggregatedAt { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a buildable code file aggregated from multiple individual code documents
/// </summary>
public class AggregatedCodeFile
{
    public string FileName { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public string Language { get; set; } = string.Empty;
    public string CodeUnitName { get; set; } = string.Empty;
    public int FunctionCount { get; set; }
    public int TotalSize { get; set; }
}